# ИНКАПСУЛЯЦИЯ. МОДИФИКАТОРЫ ДОСТУПА

В C++ можно блокировать доступ к полям извне, но сохранять доступ для методов. Для этого введены три области доступа:

1. `public` - символ в этой области доступен извне
2. `private` - символ из этой области доступен лишь собственных в методах. При наследовании (что это и как используется в ООП разберем через пару уроков) приватные поля базового класса недоступны в наследнике
3. `protected` - модификатор доступа, недоступный вне класса, как и private, но при наследовании он переходит как protected и доступен в наследнике

![image](https://github.com/user-attachments/assets/0417c38b-5d96-4d70-84cf-9ff26102d8f8)

**_Инкапсуляция_** — _механизм языка C++, ограничивающий доступ к составляющим объект компонентам (методам и полям), делает их защищенными (`protected`) или приватными (`private`), то есть доступными только внутри объекта._

Инкапсуляцию применяют когда нужно ограничить доступ к коду/сохранить некоторый участок кода без изменений со стороны пользователя.

![image](https://github.com/user-attachments/assets/108a4486-d36b-4cf5-baf4-dcf8ab7e630c)

# ФУНКЦИИ КАК ЧЛЕНЫ КЛАССА
Классы в ООП состоят из полей (свойств/атрибутов) и методов. Поля класса мы с тобой уже рассмотрели — это переменные, характеризующие объект класса. Но с этими переменными же надо как-то работать, верно?
Для этого и придумали методы!

**_Методы класса_** — _это функции, объявленные внутри класса, которые могут выполнять какие-либо действия над данными (полями/свойствами) класса._

Пример:
Вспомним наш любимый базовый класс `Point`:
```cpp
class Point{

public:

    double x = 0.0;
    double y = 0.0;

};
```
Дополним наш класс методами для работы с координатами точки:
```cpp
class Point{

public:

    double x = 0.0;
    double y = 0.0;

    // Метод для перемещения точки на расстояние (dx; dy)
    void move(double dx, double dy) {
        x += dx;
        y += dy;
    }

    // Метод для вычисления расстояния до другой точки (Point other)
    double distanceTo(const Point& other) {
        return sqrt(pow(x - other.x, 2) + pow(y - other.y, 2));
    }

    // Метод для вывода координат точки
    void display() const {
        cout << "Point(" << x << ", " << y << ")" << endl;
    }

};
```
- Ключевое слово `const` после объявления метода означает, что метод не изменяет поля объекта (пример: метод `display()` выше)
- Можно вызывать у __константных__ объектов

## РАЗДЕЛЬНАЯ РЕАЛИЗАЦИЯ МЕТОДОВ (В .H И .CPP ФАЙЛАХ)
В C++ принято разделять объявление класса (в .h файле) и реализацию его методов (в .cpp файле). Это улучшает читаемость кода и ускоряет компиляцию.

1. Объявление методов в .h файле
В заголовочном файле указываем только сигнатуры методов:
```cpp
// point.h
#include <cmath>
#include <iostream>

class Point {
public:
    double x = 0.0;
    double y = 0.0;

    // Объявления методов
    void move(double dx, double dy);
    double distanceTo(const Point& other) const;
    void display() const;
};
```
2. Реализация методов в .cpp файле
Используем оператор `::` (область видимости) для указания принадлежности метода классу:
```cpp
// point.cpp
#include "point.h"
#include <cmath>
#include <iostream>

// Реализация метода move
void Point::move(double dx, double dy) {
    x += dx;
    y += dy;
}

// Реализация метода distanceTo
double Point::distanceTo(const Point& other) const {
    return sqrt(pow(x - other.x, 2) + pow(y - other.y, 2));
}

// Реализация метода display
void Point::display() const {
    std::cout << "Point(" << x << ", " << y << ")" << std::endl;
}
```
Синтаксис:
- `ReturnType ClassName::MethodName(Parameters) { ... }`
- Константные методы помечаются `const` после списка параметров.
